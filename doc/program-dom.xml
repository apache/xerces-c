<?xml version="1.0" standalone="no"?>
<!DOCTYPE s1 SYSTEM "sbk:/style/dtd/document.dtd">

<s1 title="DOM Programming Guide">
    <anchor name="Objectives"/>
    <s2 title="Design Objectives">
      <p>The C++ DOM implementation is based on the
         <jump href="ApacheDOMC++Binding.html">Apache Recommended DOM C++ binding</jump>.</p>
      <p>The design objective aims at meeting the following requirements:
      </p>
      <ul>
      <li>Reduced memory footprint.</li>
      <li>Fast - especially for use in server style and multi-threaded applications.</li>
      <li>Good scalability on multiprocessor systems.</li>
      <li>More C++ like and less Java like.</li>
      </ul>
    </s2>

    <anchor name="ConstructXercesDOMParser"/>
    <s2 title="Constructing a XercesDOMParser">
      <p>In order to use &XercesCName; to parse XML files using DOM, you
        will need to create an instance of the XercesDOMParser class. The example
        below shows the code you need in order to create an instance of the
        XercesDOMParser.</p>

      <source>
#include &lt;xercesc/parsers/XercesDOMParser.hpp>
#include &lt;xercesc/dom/DOM.hpp>
#include &lt;xercesc/sax/HandlerBase.hpp>
#include &lt;xercesc/util/XMLString.hpp>

int main (int argc, char* args[]) {

    try {
        XMLPlatformUtils::Initialize();
    }
    catch (const XMLException&amp; toCatch) {
        char* message = XMLString::transcode(toCatch.getMessage());
        cout &lt;&lt; "Error during initialization! :\n"
             &lt;&lt; message &lt;&lt; "\n";
        delete [] message;
        return 1;
    }

    char* xmlFile = "x1.xml";
    XercesDOMParser* parser = new XercesDOMParser();
    parser->setValidationScheme(XercesDOMParser::Val_Always);    // optional.
    parser->setDoNamespaces(true);    // optional

    ErrorHandler* errHandler = (ErrorHandler*) new HandlerBase();
    parser->setErrorHandler(errHandler);

    try {
        parser->parse(xmlFile);
    }
    catch (const XMLException&amp; toCatch) {
        char* message = XMLString::transcode(toCatch.getMessage());
        cout &lt;&lt; "Exception message is: \n"
             &lt;&lt; message &lt;&lt; "\n";
        delete [] message;
        return -1;
    }
    catch (const DOMException&amp; toCatch) {
        char* message = XMLString::transcode(toCatch.getMessage());
        cout &lt;&lt; "Exception message is: \n"
             &lt;&lt; message &lt;&lt; "\n";
        delete [] message;
        return -1;
    }
    catch (...) {
        cout &lt;&lt; "Unexpected Exception \n" ;
        return -1;
    }

    delete parser;
    delete errHandler;
    return 0;
}
      </source>
    </s2>

    <anchor name="UsingDOMAPI"/>
    <s2 title="Using DOM API">
       <anchor name="AccessAPI"/>
       <s3 title="Accessing API from application code">

<source>
#include &lt;xercesc/dom/DOM.hpp></source>

      <p>The header file &lt;dom/DOM.hpp&gt; includes all the
        individual headers for the DOM API classes. </p>

       </s3>

       <anchor name="DOMClassNames"/>
       <s3 title="Class Names">
         <p>
           The DOM class names are prefixed with "DOM", e.g. "DOMNode". The intent is
           to prevent conflicts between DOM class names and other names
           that may already be in use by an application or other
           libraries that a DOM based application must link with.</p>

         <source>
   DOMDocument*   myDocument;
   DOMNode*       aNode;
   DOMText*       someText;
         </source>

       </s3>

       <anchor name="DOMObjMgmt"/>
       <s3 title="Objects Management">
         <p>Applications would use normal C++ pointers to directly access the
            implementation objects for Nodes in C++ DOM.
         </p>

         <p>Consider the following code snippets</p>


         <source>
   DOMNode*       aNode;
   DOMNode* docRootNode;

   aNode = someDocument->createElement(anElementName);
   docRootNode = someDocument->getDocumentElement();
   docRootNode->appendChild(aNode);
         </source>

      </s3>


       <anchor name="DOMMemMgmt"/>
       <s3 title="Memory Management">
         <p>The C++ DOM implementation requires users to call the DOM release() function
            to indicate the release of any orphaned Node from the application.
            Please see <jump href="ApacheDOMC++Binding.html#release">
            Apache Recommended DOM C++ binding</jump> for details.</p>
         <p>For example</p>
         <source>
    //
    //  Create a small document tree
    //

    {
        XMLCh* tempStr[100];

        XMLString::transcode("Range", tempStr, 99);
        DOMImplementation* impl = DOMImplementationRegistry::getDOMImplementation(tempStr, 0);

        XMLString::transcode("root", tempStr, 99);
        DOMDocument*   doc = impl->createDocument(0, tempStr, 0);
        DOMElement*   root = doc->getDocumentElement();

        XMLString::transcode("FirstElement", tempStr, 99);
        DOMElement*   e1 = doc->createElement(tempStr);
        root->appendChild(e1);

        XMLString::transcode("SecondElement", tempStr, 99);
        DOMElement*   e2 = doc->createElement(tempStr);
        root->appendChild(e2);

        XMLString::transcode("aTextNode", tempStr, 99);
        DOMText*       textNode = doc->createTextNode(tempStr);
        e1->appendChild(textNode);

        // call release() to release the resource associated with the range after done
        DOMRange* range = doc->createRange();
        range->release();

        // removedElement is an orphaned node, call release() to release associated resource
        DOMElement* removedElement = root->removeChild(e2);
        removedElement->release();

        // no need to release this returned object which is owned by implementation
        XMLString::transcode("*", tempStr, 99);
        DOMNodeList*    nodeList = doc->getElementsByTagName(tempStr);

        // done with the document, call release() to release the entire document resources
        doc->release();
    };
         </source>
       </s3>

       <anchor name="XMLCh"/>
       <s3 title="String Type">
         <p>The C++ DOM uses the plain, null-terminated (XMLCh *) utf-16 strings
            as the String type. The (XMLCh*) utf-16 type string has low overhead.
            All the string data would remain in memory until the document object is released.</p>

       <source>
   //C++ DOM
   const XMLCh* nodeValue = aNode->getNodeValue();
       </source>

       </s3>
    </s2>
    <anchor name="DOM3"/>
    <s2 title="DOM Level 3 Support in &XercesCName;">
      <p>The &XercesCName; &XercesCVersion; contains a partial implementation of the W3C
         Document Object Model Level 3.  This implementation is experimental.    See the document
         <jump href="dom3.html"> DOM Level 3 Support</jump> for details.
      </p>
    </s2>

    <anchor name="Deprecated"/>
    <s2 title="Deprecated - Java-like DOM">
      <p>Earlier, &XercesCName; has provided a set of C++ DOM interfaces that is
        very similar in design and use, to the Java DOM API bindings.
        Currently, such interface has been deprecated.
        See this <jump href="program-deprecateddom.html"> document </jump> for its programming details.
      </p>
    </s2>

</s1>
